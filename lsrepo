#!/usr/bin/env node

'use strict'

const dirRepos = require('./util/git').dirRepos
const isRepo = require('./util/git').isRepo
const notDir = require('./util/git').notDir
const parse = require('./util/argv')
const params = process.argv.slice(2)
const cp = require('child_process')
const Path = require('path')
const resolve = Path.resolve
const fs = require('fs')
const os = require('os')
const join = Path.join

const YELLOW = '\x1b[33m'
const GREEN = '\x1b[32m'
const PINK = '\x1b[35m'
const RED = '\x1b[31m'

const usage = `
  alias:
    -h  --help
    -d  --detail
    -nc --not-clean
    -mb --multi-branch
    -mr --multi-remote
    -rd --remote-detail

  usage:

    lsrepo anydir [--detail]
    lsrepo anydir --not-clean     [--detail]
    lsrepo anydir --multi-branch  [--detail]
    lsrepo anydir --multi-remote  [--detail]
    lsrepo anydir --remote-detail [--detail]
`

let remoteDetail = false
let multiRemote = false // only show repos with multi remotes
let multiBranch = false // only show repos with multi branches
let printUsage = false
let showDetail = false
let notClean = false // only show repos not clean
let dir = params[0] || '.'
let EOL = os.EOL
let DEPTH = 6

if (dir.startsWith('--')) {
  dir = '.'
} else if (dir === 'GO') {
  dir = process.env.GOPATH
  dir = dir ? join(dir, 'src/github.com') : '.'
}

parseArgv(params)
if (printUsage) {
  console.info(usage)
  process.exit(0)
}

dir = resolve(process.cwd(), dir)

let repoPaths = dirRepos(dir, DEPTH)

repoPaths.forEach(function(p) {
  getGitRepoInfo(p)
})

/**
 * @param {string} dir
 */
function getGitRepoInfo(dir) {
  process.chdir(dir)

  let remoteInfo = cp.spawnSync('git', ['remote'])
  let branchInfo = cp.spawnSync('git', ['branch'])
  let statusInfo = cp.spawnSync('git', ['status'])

  if (ignoreRepo(statusInfo, branchInfo, remoteInfo)) return

  let repoDir = GREEN + toLength(Path.basename(dir), 32) + dir

  if (showDetail) {
    console.log(YELLOW + '----------------------------------------------------------------')
    console.log(repoDir)

    log(remoteInfo, 1)
    log(branchInfo, 2)
    log(statusInfo, 3)
  } else {
    console.log(repoDir)

    if (multiBranch) log(branchInfo, 2)
    if (multiRemote) log(remoteInfo, 1)
    if (remoteDetail) logRemoteDetail(remoteInfo)
  }
}

function ignoreRepo(statusInfo, branchInfo, remoteInfo) {
  if (notClean && statusInfo.status === 0) {
    if (statusInfo.stdout.toString().includes('nothing to commit, working directory clean')) return true
  }

  if (multiBranch && branchInfo.status === 0) {
    if (branchInfo.stdout.toString().split(EOL).length <= 2) return true
  }

  if (multiRemote && remoteInfo.status === 0) {
    if (remoteInfo.stdout.toString().split(EOL).length <= 2) return true
  }

  return false
}

function logRemoteDetail(result) {
  if (result.status) {
    // error
    return console.error('get remote info error')
  }

  result.stdout.toString().split('\n').forEach(remote => {
    remote = remote.trim()

    if (remote) {
      let info = cp.spawnSync('git', ['remote', 'show', remote])

      if (info.status) {
        return console.error('get remote: %s detail error', remote)
      }

      let lines = info.stdout.toString().split('\n')
      let fetchURL = ''
      let pushURL = ''

      for (let line of lines) {
        line = line.trim()

        if (line.startsWith('Fetch URL:')) {
          fetchURL = trimURL(line.replace('Fetch URL:', ''))
        }

        if (line.startsWith('Push  URL:')) {
          pushURL = trimURL(line.replace('Push  URL:', ''))

          if (pushURL !== fetchURL) {
            console.info(PINK + 'remote: %s, push  URL: %s', fetchURL)
            console.info(PINK + 'remote: %s, fetch URL: %s', pushURL)
          } else {
            console.info(PINK + 'remote: %s - %s', remote, fetchURL)
          }
        }
      }
    }
  })
}

/**
 * @param {String} u
 * @return {String}
 */
function trimURL(u) {
  return u
    .trim()
    .replace(/^git@/, '')
    .replace(/.git$/, '')
    .replace(/^http:\/\//, '')
    .replace(/^https:\/\//, '')
    .replace(/^github.com/, '')
    .replace(/:/g, '')
    .replace(/^\//, '')
}

function log(result, flag) {
  if (result.status) {
    // error
    return console.error(RED + result.stderr.toString())
  }

  let COLOUR = '\x1b[3' + (flag + 3) + 'm'
  console.info(COLOUR + result.stdout.toString())
}

function toLength(string, length) {
  if (string.length < length) {
    return string + ' '.repeat(length - string.length)
  }
}

/**
 * @param {array[string]}
 */
function parseArgv(args) {
  let keys = new Set([
    '-h', '--help',
    '-d', '--detail',
    '-nc', '--not-clean',
    '-mb', '--multi-branch',
    '-mr', '--multi-remote',
    '-rd', '--remote-detail'
  ])

  args = parse(args, keys)

  if (args.has('--help') || args.has('-h')) printUsage = true
  if (args.has('--detail') || args.has('-d')) showDetail = true
  if (args.has('--not-clean') || args.has('-nc')) notClean = true
  if (args.has('--multi-branch') || args.has('-mb')) multiBranch = true
  if (args.has('--multi-remote') || args.has('-mr')) multiRemote = true
  if (args.has('--remote-detail') || args.has('-rd')) remoteDetail = true
}
