#!/usr/bin/env node

'use strict'

const parse = require('./util/argv')
const params = process.argv.slice(2)
const cp = require('child_process')
const Path = require('path')
const resolve = Path.resolve
const fs = require('fs')
const os = require('os')
const join = Path.join

const YELLOW = '\x1b[33m'
const GREEN = '\x1b[32m'
const RED = '\x1b[31m'

const usage = `
  alias:
    -h  --help
    -d  --detail
    -nc --not-clean
    -mb --multi-branch
    -mr --multi-remote

  usage:

    lsrepo anydir --not-clean    [--detail]
    lsrepo anydir --multi-branch [--detail]
    lsrepo anydir --multi-remote [--detail]
`

let multiRemote = false // only show repos with multi remotes
let multiBranch = false // only show repos with multi branches
let printUsage = false
let showDetail = false
let notClean = false // only show repos not clean
let dir = params[0] || '.'
let EOL = os.EOL
let DEPTH = 6

if (dir.startsWith('--')) {
  dir = '.'
} else if (dir === 'GO') {
  dir = process.env.GOPATH
  dir = dir ? join(dir, 'src/github.com') : '.'
}

parseArgv(params)
if (printUsage) {
  console.info(usage)
  process.exit(0)
}

dir = resolve(process.cwd(), dir)

let repoPaths = dirRepos(dir, DEPTH)

repoPaths.forEach(function(p) {
  getGitRepoInfo(p)
})

/**
 * @param {string} - dir
 */
function getGitRepoInfo(dir) {
  process.chdir(dir)

  let remoteInfo = cp.spawnSync('git', ['remote'])
  let branchInfo = cp.spawnSync('git', ['branch'])
  let statusInfo = cp.spawnSync('git', ['status'])

  if (ignoreRepo(statusInfo, branchInfo, remoteInfo)) return

  let repoDir = GREEN + toLength(Path.basename(dir), 32) + dir

  if (showDetail) {
    console.log(YELLOW + '----------------------------------------------------------------')
    console.log(repoDir)

    log(remoteInfo, 1)
    log(branchInfo, 2)
    log(statusInfo, 3)
  } else {
    console.log(repoDir)

    if (multiBranch) log(branchInfo, 2)
    if (multiRemote) log(remoteInfo, 1)
  }
}

function ignoreRepo(statusInfo, branchInfo, remoteInfo) {
  if (notClean && statusInfo.status === 0) {
    if (statusInfo.stdout.toString().includes('nothing to commit, working directory clean')) return true
  }

  if (multiBranch && branchInfo.status === 0) {
    if (branchInfo.stdout.toString().split(EOL).length <= 2) return true
  }

  if (multiRemote && remoteInfo.status === 0) {
    if (remoteInfo.stdout.toString().split(EOL).length <= 2) return true
  }

  return false
}

function log(result, flag) {
  if (result.status) {
    // error
    return console.error(RED + result.stderr.toString())
  }

  let COLOUR = '\x1b[3' + (flag + 3) + 'm'
  console.info(COLOUR + result.stdout.toString())
}

/**
 * @param {string} - path
 * @return {boolean}
 */
function notDir(path) {
  let isDir

  try {
    isDir = fs.statSync(path).isDirectory()
  } catch (e) {
    return true
  }

  return !isDir
}

/**
 * @param {string} - dir
 * @return {boolean}
 */
function isRepo(dir) {
  let p = join(dir, '.git')

  try {
    fs.statSync(p)
  } catch (e) {
    return false
  }

  return true
}

/**
 * @param {string} - path
 * @param {number} - depth
 * @return {array[string]}
 */
function dirRepos(path, depth) {
  if (!--depth) return []
  if (notDir(path)) return []
  if (isRepo(path)) return [path]

  let names = fs.readdirSync(path)
  let repos = []

  names.forEach(function(n) {
    let p = join(path, n)

    if (notDir(p)) return
    if (isRepo(p)) return repos.push(p)

    repos = repos.concat(dirRepos(p, depth))
  })

  return repos
}

function toLength(string, length) {
  if (string.length < length) {
    return string + ' '.repeat(length - string.length)
  }
}

/**
 * @param {array[string]}
 */
function parseArgv(args) {
  let keys = new Set([
    '-h', '--help',
    '-d', '--detail',
    '-nc', '--not-clean',
    '-mb', '--multi-branch',
    '-mr', '--multi-remote'
  ])

  args = parse(args, keys)

  if (args.has('--help') || args.has('-h')) printUsage = true
  if (args.has('--detail') || args.has('-d')) showDetail = true
  if (args.has('--not-clean') || args.has('-nc')) notClean = true
  if (args.has('--multi-branch') || args.has('-mb')) multiBranch = true
  if (args.has('--multi-remote') || args.has('-mr')) multiRemote = true
}
